{
  "id": "bcbd337ac361c0226ab3df95de084331",
  "solcLongVersion": "0.8.22+commit.4fc1097e",
  "input": {
    "language": "Solidity",
    "sources": {
      "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
      },
      "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
      },
      "@openzeppelin/contracts/interfaces/IERC1967.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
      },
      "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
      },
      "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
      },
      "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/proxy/Proxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "@openzeppelin/contracts/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "contracts/EndpointV2.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { MessagingFee, MessagingParams, MessagingReceipt, Origin, ILayerZeroEndpointV2 } from \"./interfaces/ILayerZeroEndpointV2.sol\";\nimport { ISendLib, Packet } from \"./interfaces/ISendLib.sol\";\nimport { ILayerZeroReceiver } from \"./interfaces/ILayerZeroReceiver.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\nimport { Transfer } from \"./libs/Transfer.sol\";\nimport { MessagingChannel } from \"./MessagingChannel.sol\";\nimport { MessagingComposer } from \"./MessagingComposer.sol\";\nimport { MessageLibManager } from \"./MessageLibManager.sol\";\nimport { MessagingContext } from \"./MessagingContext.sol\";\n\n// LayerZero EndpointV2 is fully backward compatible with LayerZero Endpoint(V1), but it also supports additional\n// features that Endpoint(V1) does not support now and may not in the future. We have also changed some terminology\n// to clarify pre-existing language that might have been confusing.\n//\n// The following is a list of terminology changes:\n//     -chainId -> eid\n//          - Rationale: chainId was a term we initially used to describe an endpoint on a specific chain. Since\n//          LayerZero supports non-EVMs we could not map the classic EVM chainIds to the LayerZero chainIds, making it\n//          confusing for developers. With the addition of EndpointV2 and its backward compatible nature, we would have\n//          two chainIds per chain that has Endpoint(V1), further confusing developers. We have decided to change the\n//          name to Endpoint Id, or eid, for simplicity and clarity.\n//     -adapterParams -> options\n//     -userApplication -> oapp. Omnichain Application\n//     -srcAddress -> sender\n//     -dstAddress -> receiver\n//          - Rationale: The sender/receiver on EVM is the address. However, on non-EVM chains, the sender/receiver could\n//          represented as a public key, or some other identifier. The term sender/receiver is more generic\n//     -payload -> message.\n//          - Rationale: The term payload is used in the context of a packet, which is a combination of the message and GUID\ncontract EndpointV2 is ILayerZeroEndpointV2, MessagingChannel, MessageLibManager, MessagingComposer, MessagingContext {\n    address public lzToken;\n\n    mapping(address oapp => address delegate) public delegates;\n\n    /// @param _eid the unique Endpoint Id for this deploy that all other Endpoints can use to send to it\n    constructor(uint32 _eid, address _owner) MessagingChannel(_eid) {\n        _transferOwnership(_owner);\n    }\n\n    /// @dev MESSAGING STEP 0\n    /// @notice This view function gives the application built on top of LayerZero the ability to requests a quote\n    /// with the same parameters as they would to send their message. Since the quotes are given on chain there is a\n    /// race condition in which the prices could change between the time the user gets their quote and the time they\n    /// submit their message. If the price moves up and the user doesn't send enough funds the transaction will revert,\n    /// if the price goes down the _refundAddress provided by the app will be refunded the difference.\n    /// @param _params the messaging parameters\n    /// @param _sender the sender of the message\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory) {\n        // lzToken must be set to support payInLzToken\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // get the correct outbound nonce\n        uint64 nonce = outboundNonce[_sender][_params.dstEid][_params.receiver] + 1;\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: nonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(nonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        // use _ to avoid variable shadowing\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        return ISendLib(_sendLibrary).quote(packet, _params.options, _params.payInLzToken);\n    }\n\n    /// @dev MESSAGING STEP 1 - OApp need to transfer the fees to the endpoint before sending the message\n    /// @param _params the messaging parameters\n    /// @param _refundAddress the address to refund both the native and lzToken\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable sendContext(_params.dstEid, msg.sender) returns (MessagingReceipt memory) {\n        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();\n\n        // send message\n        (MessagingReceipt memory receipt, address _sendLibrary) = _send(msg.sender, _params);\n\n        // OApp can simulate with 0 native value it will fail with error including the required fee, which can be provided in the actual call\n        // this trick can be used to avoid the need to write the quote() function\n        // however, without the quote view function it will be hard to compose an oapp on chain\n        uint256 suppliedNative = _suppliedNative();\n        uint256 suppliedLzToken = _suppliedLzToken(_params.payInLzToken);\n        _assertMessagingFee(receipt.fee, suppliedNative, suppliedLzToken);\n\n        // handle lz token fees\n        _payToken(lzToken, receipt.fee.lzTokenFee, suppliedLzToken, _sendLibrary, _refundAddress);\n\n        // handle native fees\n        _payNative(receipt.fee.nativeFee, suppliedNative, _sendLibrary, _refundAddress);\n\n        return receipt;\n    }\n\n    /// @dev internal function for sending the messages used by all external send methods\n    /// @param _sender the address of the application sending the message to the destination chain\n    /// @param _params the messaging parameters\n    function _send(\n        address _sender,\n        MessagingParams calldata _params\n    ) internal returns (MessagingReceipt memory, address) {\n        // get the correct outbound nonce\n        uint64 latestNonce = _outbound(_sender, _params.dstEid, _params.receiver);\n\n        // construct the packet with a GUID\n        Packet memory packet = Packet({\n            nonce: latestNonce,\n            srcEid: eid,\n            sender: _sender,\n            dstEid: _params.dstEid,\n            receiver: _params.receiver,\n            guid: GUID.generate(latestNonce, eid, _sender, _params.dstEid, _params.receiver),\n            message: _params.message\n        });\n\n        // get the send library by sender and dst eid\n        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);\n\n        // messageLib always returns encodedPacket with guid\n        (MessagingFee memory fee, bytes memory encodedPacket) = ISendLib(_sendLibrary).send(\n            packet,\n            _params.options,\n            _params.payInLzToken\n        );\n\n        // Emit packet information for DVNs, Executors, and any other offchain infrastructure to only listen\n        // for this one event to perform their actions.\n        emit PacketSent(encodedPacket, _params.options, _sendLibrary);\n\n        return (MessagingReceipt(packet.guid, latestNonce, fee), _sendLibrary);\n    }\n\n    /// @dev MESSAGING STEP 2 - on the destination chain\n    /// @dev configured receive library verifies a message\n    /// @param _origin a struct holding the srcEid, nonce, and sender of the message\n    /// @param _receiver the receiver of the message\n    /// @param _payloadHash the payload hash of the message\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external {\n        if (!isValidReceiveLibrary(_receiver, _origin.srcEid, msg.sender)) revert Errors.LZ_InvalidReceiveLibrary();\n\n        uint64 lazyNonce = lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender];\n        if (!_initializable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotInitializable();\n        if (!_verifiable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotVerifiable();\n\n        // insert the message into the message channel\n        _inbound(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, _payloadHash);\n        emit PacketVerified(_origin, _receiver, _payloadHash);\n    }\n\n    /// @dev MESSAGING STEP 3 - the last step\n    /// @dev execute a verified message to the designated receiver\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver. the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev cant reentrant because the payload is cleared before execution\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // clear the payload first to prevent reentrancy, and then execute the message\n        _clearPayload(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, abi.encodePacked(_guid, _message));\n        ILayerZeroReceiver(_receiver).lzReceive{ value: msg.value }(_origin, _guid, _message, msg.sender, _extraData);\n        emit PacketDelivered(_origin, _receiver);\n    }\n\n    /// @param _origin the origin of the message\n    /// @param _receiver the receiver of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor.\n    /// @param _reason the reason for failure\n    function lzReceiveAlert(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzReceiveAlert(_receiver, msg.sender, _origin, _guid, _gas, _value, _message, _extraData, _reason);\n    }\n\n    /// @dev Oapp uses this interface to clear a message.\n    /// @dev this is a PULL mode versus the PUSH mode of lzReceive\n    /// @dev the cleared message can be ignored by the app (effectively burnt)\n    /// @dev authenticated by oapp\n    /// @param _origin the origin of the message\n    /// @param _guid the guid of the message\n    /// @param _message the message\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external {\n        _assertAuthorized(_oapp);\n\n        bytes memory payload = abi.encodePacked(_guid, _message);\n        _clearPayload(_oapp, _origin.srcEid, _origin.sender, _origin.nonce, payload);\n        emit PacketDelivered(_origin, _oapp);\n    }\n\n    /// @dev allows reconfiguration to recover from wrong configurations\n    /// @dev users should never approve the EndpointV2 contract to spend their non-layerzero tokens\n    /// @dev override this function if the endpoint is charging ERC20 tokens as native\n    /// @dev only owner\n    /// @param _lzToken the new layer zero token address\n    function setLzToken(address _lzToken) public virtual onlyOwner {\n        lzToken = _lzToken;\n        emit LzTokenSet(_lzToken);\n    }\n\n    /// @dev recover the token sent to this contract by mistake\n    /// @dev only owner\n    /// @param _token the token to recover. if 0x0 then it is native token\n    /// @param _to the address to send the token to\n    /// @param _amount the amount to send\n    function recoverToken(address _token, address _to, uint256 _amount) external onlyOwner {\n        Transfer.nativeOrToken(_token, _to, _amount);\n    }\n\n    /// @dev handling token payments on endpoint. the sender must approve the endpoint to spend the token\n    /// @dev internal function\n    /// @param _token the token to pay\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the token\n    function _payToken(\n        address _token,\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal {\n        if (_required > 0) {\n            Transfer.token(_token, _receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.token(_token, _refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal virtual {\n        if (_required > 0) {\n            Transfer.native(_receiver, _required);\n        }\n        if (_required < _supplied) {\n            unchecked {\n                // refund the excess\n                Transfer.native(_refundAddress, _supplied - _required);\n            }\n        }\n    }\n\n    /// @dev get the balance of the lzToken as the supplied lzToken fee if payInLzToken is true\n    function _suppliedLzToken(bool _payInLzToken) internal view returns (uint256 supplied) {\n        if (_payInLzToken) {\n            supplied = IERC20(lzToken).balanceOf(address(this));\n\n            // if payInLzToken is true, the supplied fee must be greater than 0 to prevent a race condition\n            // in which an oapp sending a message with lz token and the lz token is set to a new token between the tx\n            // being sent and the tx being mined. if the required lz token fee is 0 and the old lz token would be\n            // locked in the contract instead of being refunded\n            if (supplied == 0) revert Errors.LZ_ZeroLzTokenFee();\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    function _suppliedNative() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n\n    /// @dev Assert the required fees and the supplied fees are enough\n    function _assertMessagingFee(\n        MessagingFee memory _required,\n        uint256 _suppliedNativeFee,\n        uint256 _suppliedLzTokenFee\n    ) internal pure {\n        if (_required.nativeFee > _suppliedNativeFee || _required.lzTokenFee > _suppliedLzTokenFee) {\n            revert Errors.LZ_InsufficientFee(\n                _required.nativeFee,\n                _suppliedNativeFee,\n                _required.lzTokenFee,\n                _suppliedLzTokenFee\n            );\n        }\n    }\n\n    /// @dev override this if the endpoint is charging ERC20 tokens as native\n    /// @return 0x0 if using native. otherwise the address of the native ERC20 token\n    function nativeToken() external view virtual returns (address) {\n        return address(0x0);\n    }\n\n    /// @notice delegate is authorized by the oapp to configure anything in layerzero\n    function setDelegate(address _delegate) external {\n        delegates[msg.sender] = _delegate;\n        emit DelegateSet(msg.sender, _delegate);\n    }\n\n    // ========================= Internal =========================\n    function _initializable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _lazyInboundNonce > 0 || // allowInitializePath already checked\n            ILayerZeroReceiver(_receiver).allowInitializePath(_origin);\n    }\n\n    /// @dev bytes(0) payloadHash can never be submitted\n    function _verifiable(\n        Origin calldata _origin,\n        address _receiver,\n        uint64 _lazyInboundNonce\n    ) internal view returns (bool) {\n        return\n            _origin.nonce > _lazyInboundNonce || // either initializing an empty slot or reverifying\n            inboundPayloadHash[_receiver][_origin.srcEid][_origin.sender][_origin.nonce] != EMPTY_PAYLOAD_HASH; // only allow reverifying if it hasn't been executed\n    }\n\n    /// @dev assert the caller to either be the oapp or the delegate\n    function _assertAuthorized(address _oapp) internal view override(MessagingChannel, MessageLibManager) {\n        if (msg.sender != _oapp && msg.sender != delegates[_oapp]) revert Errors.LZ_Unauthorized();\n    }\n\n    // ========================= VIEW FUNCTIONS FOR OFFCHAIN ONLY =========================\n    // Not involved in any state transition function.\n    // ====================================================================================\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _initializable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool) {\n        return _verifiable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);\n    }\n}\n"
      },
      "contracts/EndpointV2Alt.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { EndpointV2 } from \"./EndpointV2.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// @notice this is the endpoint contract for layerzero v2 deployed on chains using ERC20 as native tokens\ncontract EndpointV2Alt is EndpointV2 {\n    error LZ_OnlyAltToken();\n\n    /// @dev the altFeeToken is used for fees when the native token has no value\n    /// @dev it is immutable for gas saving. only 1 endpoint for such chains\n    address internal immutable nativeErc20;\n\n    constructor(uint32 _eid, address _owner, address _altToken) EndpointV2(_eid, _owner) {\n        nativeErc20 = _altToken;\n    }\n\n    /// @dev handling native token payments on endpoint\n    /// @dev internal function\n    /// @param _required the amount required\n    /// @param _supplied the amount supplied\n    /// @param _receiver the receiver of the native token\n    /// @param _refundAddress the address to refund the excess to\n    function _payNative(\n        uint256 _required,\n        uint256 _supplied,\n        address _receiver,\n        address _refundAddress\n    ) internal override {\n        if (msg.value > 0) revert LZ_OnlyAltToken();\n        _payToken(nativeErc20, _required, _supplied, _receiver, _refundAddress);\n    }\n\n    /// @dev return the balance of the native token\n    function _suppliedNative() internal view override returns (uint256) {\n        return IERC20(nativeErc20).balanceOf(address(this));\n    }\n\n    /// @dev check if lzToken is set to the same address\n    function setLzToken(address _lzToken) public override onlyOwner {\n        if (_lzToken == nativeErc20) revert Errors.LZ_InvalidArgument();\n        super.setLzToken(_lzToken);\n    }\n\n    function nativeToken() external view override returns (address) {\n        return nativeErc20;\n    }\n}\n"
      },
      "contracts/EndpointV2View.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Proxied } from \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./EndpointV2ViewUpgradeable.sol\";\n\ncontract EndpointV2View is EndpointV2ViewUpgradeable, Proxied {\n    function initialize(address _endpoint) external proxied initializer {\n        __EndpointV2View_init(_endpoint);\n    }\n}\n"
      },
      "contracts/EndpointV2ViewUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./interfaces/ILayerZeroEndpointV2.sol\";\n\nenum ExecutionState {\n    NotExecutable, // executor: waits for PayloadVerified event and starts polling for executable\n    VerifiedButNotExecutable, // executor: starts active polling for executable\n    Executable,\n    Executed\n}\n\ncontract EndpointV2ViewUpgradeable is Initializable {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    ILayerZeroEndpointV2 public endpoint;\n\n    function __EndpointV2View_init(address _endpoint) internal onlyInitializing {\n        __EndpointV2View_init_unchained(_endpoint);\n    }\n\n    function __EndpointV2View_init_unchained(address _endpoint) internal onlyInitializing {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n    }\n\n    function initializable(Origin memory _origin, address _receiver) public view returns (bool) {\n        try endpoint.initializable(_origin, _receiver) returns (bool _initializable) {\n            return _initializable;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @dev check if a message is verifiable.\n    function verifiable(\n        Origin memory _origin,\n        address _receiver,\n        address _receiveLib,\n        bytes32 _payloadHash\n    ) public view returns (bool) {\n        if (!endpoint.isValidReceiveLibrary(_receiver, _origin.srcEid, _receiveLib)) return false;\n\n        if (!endpoint.verifiable(_origin, _receiver)) return false;\n\n        // checked in _inbound for verify\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) return false;\n\n        return true;\n    }\n\n    /// @dev check if a message is executable.\n    /// @return ExecutionState of Executed, Executable, or NotExecutable\n    function executable(Origin memory _origin, address _receiver) public view returns (ExecutionState) {\n        bytes32 payloadHash = endpoint.inboundPayloadHash(_receiver, _origin.srcEid, _origin.sender, _origin.nonce);\n\n        // executed if the payload hash has been cleared and the nonce is less than or equal to lazyInboundNonce\n        if (\n            payloadHash == EMPTY_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.lazyInboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executed;\n        }\n\n        // executable if nonce has not been executed and has not been nilified and nonce is less than or equal to inboundNonce\n        if (\n            payloadHash != NIL_PAYLOAD_HASH &&\n            _origin.nonce <= endpoint.inboundNonce(_receiver, _origin.srcEid, _origin.sender)\n        ) {\n            return ExecutionState.Executable;\n        }\n\n        // only start active executable polling if payload hash is not empty nor nil\n        if (payloadHash != EMPTY_PAYLOAD_HASH && payloadHash != NIL_PAYLOAD_HASH) {\n            return ExecutionState.VerifiedButNotExecutable;\n        }\n\n        // return NotExecutable as a catch-all\n        return ExecutionState.NotExecutable;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
      },
      "contracts/interfaces/ILayerZeroComposer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @title ILayerZeroComposer\n */\ninterface ILayerZeroComposer {\n    /**\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev To ensure non-reentrancy, implementers of this interface MUST assert msg.sender is the corresponding EndpointV2 contract (i.e., onlyEndpointV2).\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     * @param _executor The address of the executor for the composed message.\n     * @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
      },
      "contracts/interfaces/ILayerZeroEndpointV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
      },
      "contracts/interfaces/ILayerZeroReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
      },
      "contracts/interfaces/IMessageLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
      },
      "contracts/interfaces/IMessageLibManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
      },
      "contracts/interfaces/IMessagingChannel.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
      },
      "contracts/interfaces/IMessagingComposer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
      },
      "contracts/interfaces/IMessagingContext.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
      },
      "contracts/interfaces/ISendLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
      },
      "contracts/libs/AddressCast.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
      },
      "contracts/libs/CalldataBytesLib.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
      },
      "contracts/libs/Errors.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary Errors {\n    error LZ_LzTokenUnavailable();\n    error LZ_InvalidReceiveLibrary();\n    error LZ_InvalidNonce(uint64 nonce);\n    error LZ_InvalidArgument();\n    error LZ_InvalidExpiry();\n    error LZ_InvalidAmount(uint256 required, uint256 supplied);\n    error LZ_OnlyRegisteredOrDefaultLib();\n    error LZ_OnlyRegisteredLib();\n    error LZ_OnlyNonDefaultLib();\n    error LZ_Unauthorized();\n    error LZ_DefaultSendLibUnavailable();\n    error LZ_DefaultReceiveLibUnavailable();\n    error LZ_PathNotInitializable();\n    error LZ_PathNotVerifiable();\n    error LZ_OnlySendLib();\n    error LZ_OnlyReceiveLib();\n    error LZ_UnsupportedEid();\n    error LZ_UnsupportedInterface();\n    error LZ_AlreadyRegistered();\n    error LZ_SameValue();\n    error LZ_InvalidPayloadHash();\n    error LZ_PayloadHashNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeNotFound(bytes32 expected, bytes32 actual);\n    error LZ_ComposeExists();\n    error LZ_SendReentrancy();\n    error LZ_NotImplemented();\n    error LZ_InsufficientFee(\n        uint256 requiredNative,\n        uint256 suppliedNative,\n        uint256 requiredLzToken,\n        uint256 suppliedLzToken\n    );\n    error LZ_ZeroLzTokenFee();\n}\n"
      },
      "contracts/libs/GUID.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"./AddressCast.sol\";\n\nlibrary GUID {\n    using AddressCast for address;\n\n    function generate(\n        uint64 _nonce,\n        uint32 _srcEid,\n        address _sender,\n        uint32 _dstEid,\n        bytes32 _receiver\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _srcEid, _sender.toBytes32(), _dstEid, _receiver));\n    }\n}\n"
      },
      "contracts/libs/Transfer.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    using SafeERC20 for IERC20;\n\n    address internal constant ADDRESS_ZERO = address(0);\n\n    error Transfer_NativeFailed(address _to, uint256 _value);\n    error Transfer_ToAddressIsZero();\n\n    function native(address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        (bool success, ) = _to.call{ value: _value }(\"\");\n        if (!success) revert Transfer_NativeFailed(_to, _value);\n    }\n\n    function token(address _token, address _to, uint256 _value) internal {\n        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();\n        IERC20(_token).safeTransfer(_to, _value);\n    }\n\n    function nativeOrToken(address _token, address _to, uint256 _value) internal {\n        if (_token == ADDRESS_ZERO) {\n            native(_to, _value);\n        } else {\n            token(_token, _to, _value);\n        }\n    }\n}\n"
      },
      "contracts/messagelib/BlockedMessageLib.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\n\ncontract BlockedMessageLib is ERC165 {\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (type(uint64).max, type(uint8).max, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    fallback() external {\n        revert Errors.LZ_NotImplemented();\n    }\n}\n"
      },
      "contracts/messagelib/libs/BitMaps.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
      },
      "contracts/messagelib/libs/ExecutorOptions.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { CalldataBytesLib } from \"../../libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n}\n"
      },
      "contracts/messagelib/libs/PacketV1Codec.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
      },
      "contracts/messagelib/SimpleMessageLib.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"../interfaces/IMessageLib.sol\";\nimport { Packet } from \"../interfaces/ISendLib.sol\";\nimport { ILayerZeroEndpointV2, MessagingFee, Origin } from \"../interfaces/ILayerZeroEndpointV2.sol\";\nimport { Errors } from \"../libs/Errors.sol\";\nimport { PacketV1Codec } from \"./libs/PacketV1Codec.sol\";\nimport { Transfer } from \"../libs/Transfer.sol\";\n\ncontract SimpleMessageLib is Ownable, ERC165 {\n    using SafeERC20 for IERC20;\n    using PacketV1Codec for bytes;\n\n    address public immutable endpoint;\n    address public immutable treasury;\n    uint32 public immutable localEid;\n    uint8 public constant PACKET_VERSION = 1;\n\n    address public whitelistCaller;\n\n    uint256 public lzTokenFee;\n    uint256 public nativeFee;\n\n    bytes public defaultOption;\n\n    error OnlyEndpoint();\n    error OnlyWhitelistCaller();\n    error InvalidEndpoint(address expected, address actual);\n    error ToIsAddressZero();\n    error LzTokenIsAddressZero();\n    error TransferFailed();\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        if (endpoint != msg.sender) {\n            revert OnlyEndpoint();\n        }\n        _;\n    }\n\n    constructor(address _endpoint, address _treasury) {\n        endpoint = _endpoint;\n        treasury = _treasury;\n        localEid = ILayerZeroEndpointV2(_endpoint).eid();\n        lzTokenFee = 99;\n        nativeFee = 100;\n        //        defaultOption = Options.encodeLegacyOptionsType1(200000);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // no validation logic at all\n    function validatePacket(bytes calldata packetBytes) external {\n        if (whitelistCaller != address(0x0) && msg.sender != whitelistCaller) {\n            revert OnlyWhitelistCaller();\n        }\n        Origin memory origin = Origin(packetBytes.srcEid(), packetBytes.sender(), packetBytes.nonce());\n        ILayerZeroEndpointV2(endpoint).verify(origin, packetBytes.receiverB20(), keccak256(packetBytes.payload()));\n    }\n\n    // ------------------ onlyEndpoint ------------------\n    function send(\n        Packet calldata _packet,\n        bytes memory _options,\n        bool _payInLzToken\n    ) external onlyEndpoint returns (MessagingFee memory fee, bytes memory encodedPacket, bytes memory options) {\n        encodedPacket = PacketV1Codec.encode(_packet);\n\n        options = _options.length == 0 ? defaultOption : _options;\n        _handleMessagingParamsHook(encodedPacket, options);\n\n        fee = MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    // ------------------ onlyOwner ------------------\n    function setDefaultOption(bytes memory _defaultOption) external onlyOwner {\n        defaultOption = _defaultOption;\n    }\n\n    function setMessagingFee(uint256 _nativeFee, uint256 _lzTokenFee) external onlyOwner {\n        nativeFee = _nativeFee;\n        lzTokenFee = _lzTokenFee;\n    }\n\n    function setWhitelistCaller(address _whitelistCaller) external onlyOwner {\n        whitelistCaller = _whitelistCaller;\n    }\n\n    function withdrawFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n\n        address altTokenAddr = ILayerZeroEndpointV2(endpoint).nativeToken();\n\n        // transfers native if altTokenAddr == address(0x0)\n        Transfer.nativeOrToken(altTokenAddr, _to, _amount);\n    }\n\n    function withdrawLzTokenFee(address _to, uint256 _amount) external onlyOwner {\n        if (_to == address(0x0)) {\n            revert ToIsAddressZero();\n        }\n        address lzToken = ILayerZeroEndpointV2(endpoint).lzToken();\n        if (lzToken == address(0x0)) {\n            revert LzTokenIsAddressZero();\n        }\n        IERC20(lzToken).safeTransfer(_to, _amount);\n    }\n\n    // ------------------ View ------------------\n    function quote(\n        Packet calldata /*_packet*/,\n        bytes calldata /*_options*/,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory) {\n        return MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);\n    }\n\n    function isSupportedEid(uint32) external pure returns (bool) {\n        return true;\n    }\n\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\n        return (0, 0, 2);\n    }\n\n    function messageLibType() external pure returns (MessageLibType) {\n        return MessageLibType.SendAndReceive;\n    }\n\n    // ------------------ Internal ------------------\n    function _handleMessagingParamsHook(bytes memory _encodedPacket, bytes memory _options) internal virtual {}\n\n    fallback() external payable {\n        revert Errors.LZ_NotImplemented();\n    }\n\n    receive() external payable {}\n}\n"
      },
      "contracts/MessageLibManager.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IMessageLib, MessageLibType } from \"./interfaces/IMessageLib.sol\";\nimport { IMessageLibManager, SetConfigParam } from \"./interfaces/IMessageLibManager.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { BlockedMessageLib } from \"./messagelib/BlockedMessageLib.sol\";\n\nabstract contract MessageLibManager is Ownable, IMessageLibManager {\n    address private constant DEFAULT_LIB = address(0);\n\n    // the library that reverts both on send and quote\n    // must be configured on construction and be immutable\n    address public immutable blockedLibrary;\n\n    // only registered libraries all valid libraries\n    // the blockedLibrary will be registered on construction\n    address[] internal registeredLibraries;\n    mapping(address lib => bool) public isRegisteredLibrary;\n\n    // both sendLibrary and receiveLibrary config can be lazily resolved\n    mapping(address sender => mapping(uint32 dstEid => address lib)) internal sendLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => address lib)) internal receiveLibrary;\n    mapping(address receiver => mapping(uint32 srcEid => Timeout)) public receiveLibraryTimeout;\n\n    mapping(uint32 dstEid => address lib) public defaultSendLibrary;\n    mapping(uint32 srcEid => address lib) public defaultReceiveLibrary;\n    mapping(uint32 srcEid => Timeout) public defaultReceiveLibraryTimeout;\n\n    constructor() {\n        blockedLibrary = address(new BlockedMessageLib());\n        registerLibrary(blockedLibrary);\n    }\n\n    modifier onlyRegistered(address _lib) {\n        if (!isRegisteredLibrary[_lib]) revert Errors.LZ_OnlyRegisteredLib();\n        _;\n    }\n\n    modifier isSendLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Receive) revert Errors.LZ_OnlySendLib();\n        }\n        _;\n    }\n\n    modifier isReceiveLib(address _lib) {\n        if (_lib != DEFAULT_LIB) {\n            if (IMessageLib(_lib).messageLibType() == MessageLibType.Send) revert Errors.LZ_OnlyReceiveLib();\n        }\n        _;\n    }\n\n    modifier onlyRegisteredOrDefault(address _lib) {\n        if (!isRegisteredLibrary[_lib] && _lib != DEFAULT_LIB) revert Errors.LZ_OnlyRegisteredOrDefaultLib();\n        _;\n    }\n\n    /// @dev check if the library supported the eid.\n    modifier onlySupportedEid(address _lib, uint32 _eid) {\n        /// @dev doesnt need to check for default lib, because when they are initially added they get passed through this modifier\n        if (_lib != DEFAULT_LIB) {\n            if (!IMessageLib(_lib).isSupportedEid(_eid)) revert Errors.LZ_UnsupportedEid();\n        }\n        _;\n    }\n\n    function getRegisteredLibraries() external view returns (address[] memory) {\n        return registeredLibraries;\n    }\n\n    /// @notice The Send Library is the Oapp specified library that will be used to send the message to the destination\n    /// endpoint. If the Oapp does not specify a Send Library, the default Send Library will be used.\n    /// @dev If the Oapp does not have a selected Send Library, this function will resolve to the default library\n    /// configured by LayerZero\n    /// @return lib address of the Send Library\n    /// @param _sender The address of the Oapp that is sending the message\n    /// @param _dstEid The destination endpoint id\n    function getSendLibrary(address _sender, uint32 _dstEid) public view returns (address lib) {\n        lib = sendLibrary[_sender][_dstEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultSendLibrary[_dstEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultSendLibUnavailable();\n        }\n    }\n\n    function isDefaultSendLibrary(address _sender, uint32 _dstEid) public view returns (bool) {\n        return sendLibrary[_sender][_dstEid] == DEFAULT_LIB;\n    }\n\n    /// @dev the receiveLibrary can be lazily resolved that if not set it will point to the default configured by LayerZero\n    function getReceiveLibrary(address _receiver, uint32 _srcEid) public view returns (address lib, bool isDefault) {\n        lib = receiveLibrary[_receiver][_srcEid];\n        if (lib == DEFAULT_LIB) {\n            lib = defaultReceiveLibrary[_srcEid];\n            if (lib == address(0x0)) revert Errors.LZ_DefaultReceiveLibUnavailable();\n            isDefault = true;\n        }\n    }\n\n    /// @dev called when the endpoint checks if the msgLib attempting to verify the msg is the configured msgLib of the Oapp\n    /// @dev this check provides the ability for Oapp to lock in a trusted msgLib\n    /// @dev it will fist check if the msgLib is the currently configured one. then check if the msgLib is the one in grace period of msgLib versioning upgrade\n    function isValidReceiveLibrary(\n        address _receiver,\n        uint32 _srcEid,\n        address _actualReceiveLib\n    ) public view returns (bool) {\n        // early return true if the _actualReceiveLib is the currently configured one\n        (address expectedReceiveLib, bool isDefault) = getReceiveLibrary(_receiver, _srcEid);\n        if (_actualReceiveLib == expectedReceiveLib) {\n            return true;\n        }\n\n        // check the timeout condition otherwise\n        // if the Oapp is using defaultReceiveLibrary, use the default Timeout config\n        // otherwise, use the Timeout configured by the Oapp\n        Timeout memory timeout = isDefault\n            ? defaultReceiveLibraryTimeout[_srcEid]\n            : receiveLibraryTimeout[_receiver][_srcEid];\n\n        // requires the _actualReceiveLib to be the same as the one in grace period and the grace period has not expired\n        // block.number is uint256 so timeout.expiry must > 0, which implies a non-ZERO value\n        if (timeout.lib == _actualReceiveLib && timeout.expiry > block.number) {\n            // timeout lib set and has not expired\n            return true;\n        }\n\n        // returns false by default\n        return false;\n    }\n\n    //------- Owner interfaces\n    /// @dev all libraries have to implement the erc165 interface to prevent wrong configurations\n    /// @dev only owner\n    function registerLibrary(address _lib) public onlyOwner {\n        // must have the right interface\n        if (!IERC165(_lib).supportsInterface(type(IMessageLib).interfaceId)) revert Errors.LZ_UnsupportedInterface();\n        // must have not been registered\n        if (isRegisteredLibrary[_lib]) revert Errors.LZ_AlreadyRegistered();\n\n        // insert into both the map and the list\n        isRegisteredLibrary[_lib] = true;\n        registeredLibraries.push(_lib);\n\n        emit LibraryRegistered(_lib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev can set to the blockedLibrary, which is a registered library\n    /// @dev the msgLib must enable the support before they can be registered to the endpoint as the default\n    /// @dev only owner\n    function setDefaultSendLibrary(\n        uint32 _eid,\n        address _newLib\n    ) external onlyOwner onlyRegistered(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        // must provide a different value\n        if (defaultSendLibrary[_eid] == _newLib) revert Errors.LZ_SameValue();\n        defaultSendLibrary[_eid] = _newLib;\n        emit DefaultSendLibrarySet(_eid, _newLib);\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev only owner\n    function setDefaultReceiveLibrary(\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyOwner onlyRegistered(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        address oldLib = defaultReceiveLibrary[_eid];\n        // must provide a different value\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n\n        defaultReceiveLibrary[_eid] = _newLib;\n        emit DefaultReceiveLibrarySet(_eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // override the current default timeout to the [old_lib + new expiry]\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = oldLib;\n            timeout.expiry = block.number + _gracePeriod;\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, timeout.expiry);\n        } else {\n            // otherwise, remove the old configuration.\n            delete defaultReceiveLibraryTimeout[_eid];\n            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, 0);\n        }\n    }\n\n    /// @dev owner setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2) force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setDefaultReceiveLibraryTimeout(\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) onlyOwner {\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete defaultReceiveLibraryTimeout[_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit DefaultReceiveLibraryTimeoutSet(_eid, _lib, _expiry);\n    }\n\n    /// @dev returns true only if both the default send/receive libraries are set\n    function isSupportedEid(uint32 _eid) external view returns (bool) {\n        return defaultSendLibrary[_eid] != address(0) && defaultReceiveLibrary[_eid] != address(0);\n    }\n\n    //------- OApp interfaces\n    /// @dev Oapp setting the sendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev authenticated by the Oapp\n    function setSendLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib\n    ) external onlyRegisteredOrDefault(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        // must provide a different value\n        if (sendLibrary[_oapp][_eid] == _newLib) revert Errors.LZ_SameValue();\n        sendLibrary[_oapp][_eid] = _newLib;\n        emit SendLibrarySet(_oapp, _eid, _newLib);\n    }\n\n    /// @dev Oapp setting the receiveLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.\n    /// @dev authenticated by the Oapp\n    /// @param _gracePeriod the number of blocks from now until oldLib expires\n    function setReceiveLibrary(\n        address _oapp,\n        uint32 _eid,\n        address _newLib,\n        uint256 _gracePeriod\n    ) external onlyRegisteredOrDefault(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {\n        _assertAuthorized(_oapp);\n\n        address oldLib = receiveLibrary[_oapp][_eid];\n        // must provide new values\n        if (oldLib == _newLib) revert Errors.LZ_SameValue();\n        receiveLibrary[_oapp][_eid] = _newLib;\n        emit ReceiveLibrarySet(_oapp, _eid, _newLib);\n\n        if (_gracePeriod > 0) {\n            // to simplify the logic, we only allow to set timeout if neither the new lib nor old lib is DEFAULT_LIB, which would should read the default timeout configurations\n            // (1) if the Oapp wants to fall back to the DEFAULT, then set the newLib to DEFAULT with grace period == 0\n            // (2) if the Oapp wants to change to a non DEFAULT from DEFAULT, then set the newLib to 'non-default' with _gracePeriod == 0, then use setReceiveLibraryTimeout() interface\n            if (oldLib == DEFAULT_LIB || _newLib == DEFAULT_LIB) revert Errors.LZ_OnlyNonDefaultLib();\n\n            // write to storage\n            Timeout memory timeout = Timeout({ lib: oldLib, expiry: block.number + _gracePeriod });\n            receiveLibraryTimeout[_oapp][_eid] = timeout;\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, timeout.expiry);\n        } else {\n            delete receiveLibraryTimeout[_oapp][_eid];\n            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, 0);\n        }\n    }\n\n    /// @dev Oapp setting the defaultSendLibrary\n    /// @dev must be a registered library (including blockLibrary) with the eid support enabled\n    /// @dev can used to (1) extend the current configuration (2)  force remove the current configuration (3) change to a new configuration\n    /// @param _expiry the block number when lib expires\n    function setReceiveLibraryTimeout(\n        address _oapp,\n        uint32 _eid,\n        address _lib,\n        uint256 _expiry\n    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) {\n        _assertAuthorized(_oapp);\n\n        (, bool isDefault) = getReceiveLibrary(_oapp, _eid);\n        // if current library is DEFAULT, Oapp cant set the timeout\n        if (isDefault) revert Errors.LZ_OnlyNonDefaultLib();\n\n        if (_expiry == 0) {\n            // force remove the current configuration\n            delete receiveLibraryTimeout[_oapp][_eid];\n        } else {\n            // override it with new configuration\n            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();\n            Timeout storage timeout = receiveLibraryTimeout[_oapp][_eid];\n            timeout.lib = _lib;\n            timeout.expiry = _expiry;\n        }\n        emit ReceiveLibraryTimeoutSet(_oapp, _eid, _lib, _expiry);\n    }\n\n    //------- library config setter/getter. all pass-through functions to the msgLib\n\n    /// @dev authenticated by the _oapp\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external onlyRegistered(_lib) {\n        _assertAuthorized(_oapp);\n\n        IMessageLib(_lib).setConfig(_oapp, _params);\n    }\n\n    /// @dev a view function to query the current configuration of the OApp\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view onlyRegistered(_lib) returns (bytes memory config) {\n        return IMessageLib(_lib).getConfig(_eid, _oapp, _configType);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
      },
      "contracts/MessagingChannel.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingChannel } from \"./interfaces/IMessagingChannel.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\nimport { GUID } from \"./libs/GUID.sol\";\n\nabstract contract MessagingChannel is IMessagingChannel {\n    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);\n    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);\n\n    // The universally unique id (UUID) of this deployed Endpoint\n    uint32 public immutable eid;\n\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)))\n        public lazyInboundNonce;\n    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => mapping(uint64 inboundNonce => bytes32 payloadHash))))\n        public inboundPayloadHash;\n    mapping(address sender => mapping(uint32 dstEid => mapping(bytes32 receiver => uint64 nonce))) public outboundNonce;\n\n    /// @param _eid is the universally unique id (UUID) of this deployed Endpoint\n    constructor(uint32 _eid) {\n        eid = _eid;\n    }\n\n    /// @dev increase and return the next outbound nonce\n    function _outbound(address _sender, uint32 _dstEid, bytes32 _receiver) internal returns (uint64 nonce) {\n        unchecked {\n            nonce = ++outboundNonce[_sender][_dstEid][_receiver];\n        }\n    }\n\n    /// @dev inbound won't update the nonce eagerly to allow unordered verification\n    /// @dev instead, it will update the nonce lazily when the message is received\n    /// @dev messages can only be cleared in order to preserve censorship-resistance\n    function _inbound(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes32 _payloadHash\n    ) internal {\n        if (_payloadHash == EMPTY_PAYLOAD_HASH) revert Errors.LZ_InvalidPayloadHash();\n        inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] = _payloadHash;\n    }\n\n    /// @dev returns the max index of the longest gapless sequence of verified msg nonces.\n    /// @dev the uninitialized value is 0. the first nonce is always 1\n    /// @dev it starts from the lazyInboundNonce (last checkpoint) and iteratively check if the next nonce has been verified\n    /// @dev this function can OOG if too many backlogs, but it can be trivially fixed by just clearing some prior messages\n    /// @dev NOTE: Oapp explicitly skipped nonces count as \"verified\" for these purposes\n    /// @dev eg. [1,2,3,4,6,7] => 4, [1,2,6,8,10] => 2, [1,3,4,5,6] => 1\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) public view returns (uint64) {\n        uint64 nonceCursor = lazyInboundNonce[_receiver][_srcEid][_sender];\n\n        // find the effective inbound currentNonce\n        unchecked {\n            while (_hasPayloadHash(_receiver, _srcEid, _sender, nonceCursor + 1)) {\n                ++nonceCursor;\n            }\n        }\n        return nonceCursor;\n    }\n\n    /// @dev checks if the storage slot is not initialized. Assumes computationally infeasible that payload can hash to 0\n    function _hasPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) internal view returns (bool) {\n        return inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] != EMPTY_PAYLOAD_HASH;\n    }\n\n    /// @dev the caller must provide _nonce to prevent skipping the unintended nonce\n    /// @dev it could happen in some race conditions, e.g. to skip nonce 3, but nonce 3 was consumed first\n    /// @dev usage: skipping the next nonce to prevent message verification, e.g. skip a message when Precrime throws alerts\n    /// @dev if the Oapp wants to skip a verified message, it should call the clear() function instead\n    /// @dev after skipping, the lazyInboundNonce is set to the provided nonce, which makes the inboundNonce also the provided nonce\n    /// @dev ie. allows the Oapp to increment the lazyInboundNonce without having had that corresponding msg be verified\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external {\n        _assertAuthorized(_oapp);\n\n        if (_nonce != inboundNonce(_oapp, _srcEid, _sender) + 1) revert Errors.LZ_InvalidNonce(_nonce);\n        lazyInboundNonce[_oapp][_srcEid][_sender] = _nonce;\n        emit InboundNonceSkipped(_srcEid, _sender, _oapp, _nonce);\n    }\n\n    /// @dev Marks a packet as verified, but disallows execution until it is re-verified.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev A non-verified nonce can be nilified by passing EMPTY_PAYLOAD_HASH for _payloadHash.\n    /// @dev Assumes the computational intractability of finding a payload that hashes to bytes32.max.\n    /// @dev Authenticated by the caller\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (_nonce <= lazyInboundNonce[_oapp][_srcEid][_sender] && curPayloadHash == EMPTY_PAYLOAD_HASH)\n            revert Errors.LZ_InvalidNonce(_nonce);\n        // set it to nil\n        inboundPayloadHash[_oapp][_srcEid][_sender][_nonce] = NIL_PAYLOAD_HASH;\n        emit PacketNilified(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev Marks a nonce as unexecutable and un-verifiable. The nonce can never be re-verified or executed.\n    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.\n    /// @dev Only packets with nonces less than or equal to the lazy inbound nonce can be burned.\n    /// @dev Reverts if the nonce has already been executed.\n    /// @dev Authenticated by the caller\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {\n        _assertAuthorized(_oapp);\n\n        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);\n        if (curPayloadHash == EMPTY_PAYLOAD_HASH || _nonce > lazyInboundNonce[_oapp][_srcEid][_sender])\n            revert Errors.LZ_InvalidNonce(_nonce);\n        delete inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];\n        emit PacketBurnt(_srcEid, _sender, _oapp, _nonce, _payloadHash);\n    }\n\n    /// @dev calling this function will clear the stored message and increment the lazyInboundNonce to the provided nonce\n    /// @dev if a lot of messages are queued, the messages can be cleared with a smaller step size to prevent OOG\n    /// @dev NOTE: this function does not change inboundNonce, it only changes the lazyInboundNonce up to the provided nonce\n    function _clearPayload(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal returns (bytes32 actualHash) {\n        uint64 currentNonce = lazyInboundNonce[_receiver][_srcEid][_sender];\n        if (_nonce > currentNonce) {\n            unchecked {\n                // try to lazily update the inboundNonce till the _nonce\n                for (uint64 i = currentNonce + 1; i <= _nonce; ++i) {\n                    if (!_hasPayloadHash(_receiver, _srcEid, _sender, i)) revert Errors.LZ_InvalidNonce(i);\n                }\n                lazyInboundNonce[_receiver][_srcEid][_sender] = _nonce;\n            }\n        }\n\n        // check the hash of the payload to verify the executor has given the proper payload that has been verified\n        actualHash = keccak256(_payload);\n        bytes32 expectedHash = inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n        if (expectedHash != actualHash) revert Errors.LZ_PayloadHashNotFound(expectedHash, actualHash);\n\n        // remove it from the storage\n        delete inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];\n    }\n\n    /// @dev returns the GUID for the next message given the path\n    /// @dev the Oapp might want to include the GUID into the message in some cases\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32) {\n        uint64 nextNonce = outboundNonce[_sender][_dstEid][_receiver] + 1;\n        return GUID.generate(nextNonce, eid, _sender, _dstEid, _receiver);\n    }\n\n    function _assertAuthorized(address _oapp) internal virtual;\n}\n"
      },
      "contracts/MessagingComposer.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingComposer } from \"./interfaces/IMessagingComposer.sol\";\nimport { ILayerZeroComposer } from \"./interfaces/ILayerZeroComposer.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\nabstract contract MessagingComposer is IMessagingComposer {\n    bytes32 private constant NO_MESSAGE_HASH = bytes32(0);\n    bytes32 private constant RECEIVED_MESSAGE_HASH = bytes32(uint256(1));\n\n    mapping(address from => mapping(address to => mapping(bytes32 guid => mapping(uint16 index => bytes32 messageHash))))\n        public composeQueue;\n\n    /// @dev the Oapp sends the lzCompose message to the endpoint\n    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function\n    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time\n    /// @dev authenticated by the msg.sender\n    /// @param _to the address which will receive the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n        // must have not been sent before\n        if (composeQueue[msg.sender][_to][_guid][_index] != NO_MESSAGE_HASH) revert Errors.LZ_ComposeExists();\n        composeQueue[msg.sender][_to][_guid][_index] = keccak256(_message);\n        emit ComposeSent(msg.sender, _to, _guid, _index, _message);\n    }\n\n    /// @dev execute a composed messages from the sender to the composer (receiver)\n    /// @dev the execution provides the execution context (caller, extraData) to the receiver.\n    ///      the receiver can optionally assert the caller and validate the untrusted extraData\n    /// @dev can not re-entrant\n    /// @param _from the address which sends the composed message. in most cases, it is the Oapp's address.\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable {\n        // assert the validity\n        bytes32 expectedHash = composeQueue[_from][_to][_guid][_index];\n        bytes32 actualHash = keccak256(_message);\n        if (expectedHash != actualHash) revert Errors.LZ_ComposeNotFound(expectedHash, actualHash);\n\n        // marks the message as received to prevent reentrancy\n        // cannot just delete the value, otherwise the message can be sent again and could result in some undefined behaviour\n        // even though the sender(composing Oapp) is implicitly fully trusted by the composer.\n        // eg. sender may not even realize it has such a bug\n        composeQueue[_from][_to][_guid][_index] = RECEIVED_MESSAGE_HASH;\n        ILayerZeroComposer(_to).lzCompose{ value: msg.value }(_from, _guid, _message, msg.sender, _extraData);\n        emit ComposeDelivered(_from, _to, _guid, _index);\n    }\n\n    /// @param _from the address which sends the composed message\n    /// @param _to the address which receives the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    /// @param _extraData the extra data provided by the executor\n    /// @param _reason the reason why the message is not received\n    function lzComposeAlert(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        uint256 _gas,\n        uint256 _value,\n        bytes calldata _message,\n        bytes calldata _extraData,\n        bytes calldata _reason\n    ) external {\n        emit LzComposeAlert(_from, _to, msg.sender, _guid, _index, _gas, _value, _message, _extraData, _reason);\n    }\n}\n"
      },
      "contracts/MessagingContext.sol": {
        "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { IMessagingContext } from \"./interfaces/IMessagingContext.sol\";\nimport { Errors } from \"./libs/Errors.sol\";\n\n/// this contract acts as a non-reentrancy guard and a source of messaging context\n/// the context includes the remote eid and the sender address\n/// it separates the send and receive context to allow messaging receipts (send back on receive())\nabstract contract MessagingContext is IMessagingContext {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private _sendContext = NOT_ENTERED;\n\n    /// @dev the sendContext is set to 8 bytes 0s + 4 bytes eid + 20 bytes sender\n    modifier sendContext(uint32 _dstEid, address _sender) {\n        if (_sendContext != NOT_ENTERED) revert Errors.LZ_SendReentrancy();\n        _sendContext = (uint256(_dstEid) << 160) | uint160(_sender);\n        _;\n        _sendContext = NOT_ENTERED;\n    }\n\n    /// @dev returns true if sending message\n    function isSendingMessage() public view returns (bool) {\n        return _sendContext != NOT_ENTERED;\n    }\n\n    /// @dev returns (eid, sender) if sending message, (0, 0) otherwise\n    function getSendContext() external view returns (uint32, address) {\n        return isSendingMessage() ? _getSendContext(_sendContext) : (0, address(0));\n    }\n\n    function _getSendContext(uint256 _context) internal pure returns (uint32, address) {\n        return (uint32(_context >> 160), address(uint160(_context)));\n    }\n}\n"
      },
      "contracts/proxy/TransparentUpgradeableProxy.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport { ERC1967Proxy } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\n * to support custom errors.\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error AdminAccessDenied();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            revert AdminAccessDenied();\n        }\n        super._beforeFallback();\n    }\n}\n"
      },
      "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 20000
      },
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "devdoc",
            "userdoc",
            "storageLayout",
            "evm.gasEstimates"
          ],
          "": [
            "ast"
          ]
        }
      },
      "metadata": {
        "useLiteralContent": true
      }
    }
  }
}